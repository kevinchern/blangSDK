package mrf.hotpotts

import blang.mrf.MRFInteractor
import blang.mrf.MRFGraph
import blang.mrf.hotpotts.HPSingle

model IMC {
  /*
   * IMPORTANT: 
   *   laws block:      logf are unnormalized
   *   generate block:  an inexact, Gibbs sampler is used to generate data
   *   Data:            vertices of graph must be consecutive integers from 0 to n-1
   */
  
  param Integer numClusters ?: 3  // = K.maxSize
  param GlobalDataSource expressionData
  
  param Plate<String> P   // [P]atient
  param Plate<String> N   // [N]ode
  param Plate<String> R   // p[R]otein channel
//  param Plate<Integer> C  // patient [C]lass
  param Plate<Integer> K  // [K]cluster

  param Integer nGibbsIter ?: 5
  param Plated<MRFGraph> graph 

//  random Plated<RealVar> mu
//  random Plated<RealVar> sigma
//  random Plated<IntVar> Z
  random Plated<IntVar> X
  random Plated<RealVar> Y
//  param Plated<MRFInteractor> beta  // TODO: MAKE THIS RANDOM
  param MRFInteractor beta ?: new HPSingle(numClusters)

  laws {
      for (Index<String> p : P.indices) {
          X.slice(p) | beta, N, numClusters, MRFGraph g = graph.get(p)
                     ~ HotPotts(100, N, numClusters, g, beta)
      }
    
    // Y.get(p, n, r)
//    for (Index<String> p : P.indices()) {
//        for (Index<String> r : R.indices) {
//            for (Index<Integer> n : N.indices) {
//                Y.get(p, n, r) | IntVar z = X.get(p, n), mu, sigma, K  ~ Normal(mu.get(K.index(z)), pow(sigma.get(K.index(z)), 2))
//            }
//        }
//    }

    // X.get(p, n)
    // Just need all edge potentials
//    for (Index<String> p : P.indices()) {
//        for (UnorderedPair<Integer, Integer> edge : graph.get(p).instance.edgeList) {
//          | IntVar z = Z.get(p),
//            beta, C,
//            IntVar u = X.get(p, N.index(edge.getFirst())),
//            IntVar v = X.get(p, N.index(edge.getSecond()))
//            ~ LogPotential(beta.get(C.index(z)).logEdgePotential(u, v))
//        }
//    }
    
    // Theta priors
//    for (Index<Integer> k : K.indices) {
//        for (Index<String> r : R.indices) {
//            mu.get(k, r) ~ Normal(0, 100)
//            sigma.get(k, r) ~ Gamma(1, 0.1)
//        }
//    }
    
    // Beta priors
    // Z priors
     
  }
  

}